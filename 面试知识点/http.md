## http和https
  - http: 超文本传输协议，htpps: 超文本传输安全协议
  - 安全性：
    - http: 数据以明文传输，容易被窃听、篡改、劫持
    - https: 使用TSL/SSL协议加密数据，提供更高的安全性
  - 端口：
    - http: 默认使用80端口
    - https: 默认使用443端口
  - URL前缀：
    - http: URL以“http://”开头
    - https: URL以“https://"开头
  - 加密：
    - http: 不加密
    - https: 使用对称加密和非对称加密相结合的方式
      - 对称加密：加密和解密使用相同的密钥
      - 非对称加密：加密和解密使用不同的密钥
  - 证书：
    - http: 不需要证书
    - https: 需要SSL证书
  - SEO：
    - http: 在搜索引擎排名中不如 HTTPS 网站
    - https: 得到搜索引擎的优待，可能获得更高的排名
  - 身份验证：
    - http: 不需要身份验证
    - https: 通过证书提供服务器身份验证，确保用户连接到正确的服务器

## TCP和UDP
  - TCP: 传输控制协议，UDP: 用户数据报协议
  - TCP
    - 1.连接导向：
      - 在传输数据前建立连接（三次握手）
      - 传输完成后断开连接（四次挥手）
    - 2.可靠性
      - 保证数据的可靠传输
      - 使用序列号和确认机制
    - 3.流量控制：
      - 使用滑动窗口机制进行流量控制
    - 4.拥塞控制
      - 实现网络拥塞控制
    - 5.数据顺序
      - 保证数据按发送顺序到达
    - 6.错误检测
      - 使用校验和来检测数据错误
    - 7.重传机制
      - 丢失的数据包会被重新传输
    - 8.适用场景
      - 需要可靠数据传输的应用，如网页浏览、电子邮件、文件传输
    - 9.速度
      - 相对较慢，因为有额外的控制开销
    - 10.头部大小
      - 20字节的标准头部
  - UDP (用户数据报协议)
    - 1.无连接
      - 不需要建立连接就可以直接发送数据
    - 2.不可靠性
      - 不保证数据的可靠传输，数据可能丢失或重复
    - 3.无流量控制
      - 不实施流量控制
    - 4.无拥塞控制
      - 不实施拥塞控制
    - 5.数据顺序
      - 不保证数据按顺序到达
    - 6.错误检测
      - 有基本的错误检测（校验和），但不进行错误恢复
    - 7.无重传机制
      - 没有重传机制，数据包丢失后需要应用层自行处理
    - 8.适用场景
      - 实时应用，如视频会议、在线游戏、直播等
    - 9.速度
      - 相对较快，因为没有额外的控制开销
    - 10.头部大小
      - 8字节的标准头部
  - 适用场景
    - TCP: 需要可靠数据传输的应用，如网页浏览、电子邮件、文件传输、远程登录等
    - UDP: 实时应用，如视频会议、在线游戏、直播等

## ISO七层模型
  - 物理层：负责比特流的传输
  - 数据链路层：负责数据帧的传输
  - 网络层：负责数据包的路由和转发
  - 传输层：提供端到端的可靠数据传输服务
  - 会话层：建立、管理和终止会话
  - 表示层：数据格式转换、加密解密、压缩解压缩
  - 应用层：提供应用程序间的通信

## TCP/IP，传输控制协议/网际协议
  - TCP/IP（传输控制协议/互联网协议）是互联网的基础通信协议，它定义了数据如何在网络上打包、寻址、传输、路由和接收，TCP/IP 模型是一个四层模型，相比 OSI 七层模型更为简化和实用
  - 网络接口层： 对应 OSI 模型的物理层和数据链路层，处理物理接口和数据链路的细节
  - 网络层： 对应 OSI 模型的网络层，负责数据包的路由和转发
  - 传输层： 对应 OSI 模型的传输层，提供端到端的可靠数据传输服务
  - 应用层：对应 OSI 模型的会话层、表示层和应用层

## DNS协议
  - DNS（Domain Name System）域名系统，是互联网的一项服务，用于将域名解析为IP地址
  - 域名缓存： 
    - 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
    - 操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件
  - DNS查询过程
    - 1.浏览器缓存检查
    - 2.操作系统缓存检查
    - 3.路由器缓存检查
    - 4.ISP DNS 缓存检查：如果前面都没有找到，查询会发送到互联网服务提供商（ISP）的 DNS 服务器
    - 5.递归查询开始：如果 ISP 的 DNS 服务器也没有缓存该域名，就会开始递归查询过程
    - 6.根域名服务器查询：ISP 的 DNS 服务器首先会向根域名服务器发送查询，根服务器会返回负责 .com、.org 等顶级域名的 TLD（Top-Level Domain）服务器的 IP 地址
    - 7.TLD 服务器查询：DNS 服务器接着向 TLD 服务器发送查询，TLD 服务器会返回负责该特定域名的权威域名服务器的 IP 地址
    - 8.权威域名服务器查询：DNS 服务器然后向权威域名服务器发送查询，权威服务器返回该域名的 IP 地址
    - 9.ISP DNS 服务器缓存结果
    - 10.结果返回客户端：DNS 服务器将 IP 地址返回给客户端的操作系统
    - 11.操作系统将 IP 地址存储在其 DNS 缓存中
    - 12.浏览器最终接收到 IP 地址，并可以开始建立与web服务器的连接

## CDN
  - CDN (全称 Content Delivery Network)，即内容分发网络,是一种通过在多个地理位置部署服务器节点来加速内容分发的技术。CDN的主要作用是将网站的静态资源（如图片、CSS、JavaScript文件等）缓存到离用户较近的服务器上，从而减少用户请求的响应时间，提高网站的加载速度和性能
  - 工作原理
    - CDN 会在多个地理位置部署服务器节点，每个节点都有一份完整的网站内容副本
    - 当用户访问网站时，CDN 会根据用户的 IP 地址或地理位置，选择离用户最近的服务器节点，将网站内容返回给用户

## 常见状态码
  - 1xx: 信息性状态码
    - 100: 这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝
    - 101: 客户端要求服务器升级协议版本
  - 2xx: 成功状态码
    - 200: 请求成功
    - 201: 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回
    - 202: 请求被接受，但是处理尚未完成
    - 203: 请求被成功处理，但是返回的信息可能来自另一来源
    - 204: 请求已经成功处理，但没有返回任何内容
    - 205: 请求已经成功处理，但是没有返回任何内容，并且要求请求方重置文档视图
    - 206: 请求已经成功处理，但是只有部分内容
  - 3xx: 重定向状态码
    - 300: 请求的资源可在多处得到
    - 301: 请求的资源已经被永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一
    - 302: 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
    - 303: 请求的资源可以在另一个 URI 下被找到，而且客户端应当采用 GET 的方式访问那个资源
    - 304: 如果客户端发送了一个带条件的 GET 请求，而服务器端允许不满足条件的 GET 请求的话，就会返回这个状态码
    - 307: 类似于 302 Found，但明确要求客户端使用原始请求方法重新发送请求
  - 4xx: 客户端错误状态码
    - 400: 请求报文中存在语法错误，服务器无法理解客户端的请求
    - 401: 请求需要用户的身份认证
    - 403: 服务器拒绝请求
    - 404: 服务器找不到请求的资源
    - 405: 请求方法不被允许
    - 406: 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体
    - 407: 客户端应当首先使用代理进行认证，然后重试请求
    - 408: 客户端没有在用户指定的期限内发送请求,超时
  - 5xx: 服务器错误状态码
    - 500: 服务器内部错误
    - 501: 服务器不支持请求的功能
    - 502: 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应
    - 503: 服务器超载或暂停服务
    - 504: 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应
    - 505: 服务器不支持请求中所使用的 HTTP 协议版本

 常见的HTTP方法
  - GET: 请求资源
    - 用于从服务器获取数据
    - GET方法是安全的，不会改变服务器上的数据
    - 数据位置：查询参数在 URL 中
    - 示例：GET /users?id=123
  - POST: 提交数据
    - 用于向服务器提交数据，通常用于创建新资源
    - 数据包含在请求体中
    - 可能会改变服务器状态
  - PUT: 更新资源
    - 用于更新服务器上的资源
    - 数据位置：请求体
  - DELETE: 删除资源
    - 数据位置：通常在 URL 中，有时在请求体
  - PATCH: 部分更新资源
    - 数据位置：请求体 

## http常见请求头

| 字段名 | 说明 | 示例 |
|-------|--------|--|
| Accept | 客户端可接受的媒体类型 | Accept: text/html, application/json |
| Accept-Charset | 客户端可接受的字符集 | Accept-Charset: utf-8, iso-8859-1 |
| Accept-Encoding | 客户端可接受的编码 | Accept-Encoding: gzip, deflate |
| Accept-Language | 客户端可接受的语言 | Accept-Language: en-US, fr |
| Authorization   | 用于朝文办传输协议认证的认证信息| Authorization: Bearer token123|
| cache-control   | 指定请求和响应遵循的缓存机制| cache-control: no-cache|
| Connection | 指定是否需要持久连接 | Connection: keep-alive |
| Content-Length | 指定请求体的长度 | Content-Length: 100 |
| Content-Type | 指定请求体的媒体类型 | Content-Type: application/json |
| Cookie | 客户端发送给服务器的 Cookie | Cookie: user=John; session=abc123 |
| Host | 指定请求的目标主机和端口 | Host: www.example.com |

## tcp三次握手四次挥手
  - 三次握手
    - 1.第一次握手：客户端向服务器发送一个 SYN 报文，请求建立连接， 进入 SYN_SENT 状态，SYN = 1, seq = x（x 为随机数）
    - 2.第二次握手：服务器向客户端发送一个 SYN 报文和一个 ACK 报文，确认连接请求，并发送自己的 SYN 序列号
    - 3.第三次握手：客户端收到 SYN+ACK 包，发送 ACK 包，进入 ESTABLISHED 状态，
    ACK = 1, seq = x + 1, ack = y + 1
    此时，服务器收到 ACK 后也进入 ESTABLISHED 状态，连接建立完成
    ```plainText
    客户端                 服务器
      |                      |
      | --------SYN--------> |
      |                      |
      | <--------SYN+ACK---- |
      |                      |
      | --------ACK--------> |
    ```
  - 四次挥手
    - 1.第一次挥手：客户端向服务器发送一个 FIN 报文，请求关闭连接，进入 FIN_WAIT_1 状态，FIN = 1, seq = x
    - 2.第二次挥手：服务器向客户端发送一个 ACK 报文，确认关闭请求，进入 CLOSE_WAIT 状态，ACK = 1, seq = y, ack = x + 1
    - 3.第三次挥手：服务器向客户端发送一个 FIN 报文，请求关闭连接，进入 LAST_ACK 状态，FIN = 1, seq = z
    - 4.第四次挥手：客户端收到 FIN 报文，发送一个 ACK 报文，进入 TIME_WAIT 状态，ACK = 1, seq = x + 1, ack = z + 1
    - 5.等待 2MSL 后，客户端关闭连接，进入 CLOSED 状态
    ```plainText
      客户端                服务器
        |                    |
        |------- FIN ------->|
        |                    |
        |<------ ACK --------|
        |                    |
        |<------ FIN --------|
        |                    |
        |------- ACK ------->|
        |                    |
    ```
  - 为什么需要三次握手四次挥手
    - 三次握手：确保双方都能收发数据，避免资源浪费
    - 确保双方都完成了数据传输，可以安全地关闭连接